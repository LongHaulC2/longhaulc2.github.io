"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[773],{4138(e,t,n){n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"02 Implants/Systems/MemStore","title":"Memory Store (MemStore) Architecture","description":"The MemStore is a volatile, in-memory storage engine. It serves as a (somewhat) secure staging ground for files, tools, or any data you want, allowing various workflows without extra disk interactions.","source":"@site/docs/02 Implants/Systems/MemStore.md","sourceDirName":"02 Implants/Systems","slug":"/02 Implants/Systems/MemStore","permalink":"/02 Implants/Systems/MemStore","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Module: run_bof (Run Beacon Object File)","permalink":"/02 Implants/Modules/BOF.cpp"},"next":{"title":"test","permalink":"/02 Implants/test"}}');var i=n(4848),r=n(8453);const o={},a="Memory Store (MemStore) Architecture",l={},d=[{value:"Design Philosophy &amp; Motivation",id:"design-philosophy--motivation",level:3},{value:"Storage Strategy",id:"storage-strategy",level:3},{value:"Heap Obfuscation (Data Masking)",id:"heap-obfuscation-data-masking",level:3},{value:"Memory Hygiene &amp; Ownership",id:"memory-hygiene--ownership",level:3},{value:"Integration with C2 Commands [not implemented]",id:"integration-with-c2-commands-not-implemented",level:3}];function h(e){const t={code:"code",em:"em",h1:"h1",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"memory-store-memstore-architecture",children:"Memory Store (MemStore) Architecture"})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.strong,{children:"MemStore"})," is a volatile, in-memory storage engine. It serves as a (somewhat) secure staging ground for files, tools, or any data you want, allowing various workflows without extra disk interactions."]}),"\n",(0,i.jsx)(t.h3,{id:"design-philosophy--motivation",children:"Design Philosophy & Motivation"}),"\n",(0,i.jsxs)(t.p,{children:["Traditional tradecraft often involves dropping files to disk (e.g., in ",(0,i.jsx)(t.code,{children:"C:\\Temp\\"})," or ",(0,i.jsx)(t.code,{children:"%APPDATA%"}),") to execute them or exfiltrate them. While you ",(0,i.jsx)(t.em,{children:"can"})," do this with the ",(0,i.jsx)(t.code,{children:"file upload"})," and ",(0,i.jsx)(t.code,{children:"file download"})," commands, this creates artifacts that are easily inspected by Antivirus and EDR solutions."]}),"\n",(0,i.jsxs)(t.p,{children:["The MemStore solves this by creating a (very simple) ",(0,i.jsx)(t.strong,{children:"virtual file store entirely in RAM"}),"."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Artifact Reduction:"})," Files stored here exist only in volatile memory. If the process is killed or the host reboots, the data vanishes instantly, leaving no forensic trace on the disk."]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"storage-strategy",children:"Storage Strategy"}),"\n",(0,i.jsxs)(t.p,{children:["At its core, the MemStore functions as a ",(0,i.jsx)(t.strong,{children:"Key-Value Store"})," (it literally uses a ",(0,i.jsx)(t.code,{children:"std::map<std::string, uint8_t>"}),")."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Keys:"})," Simple string identifiers (filenames) used to reference the data."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Values:"})," The raw binary data."]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"heap-obfuscation-data-masking",children:"Heap Obfuscation (Data Masking)"}),"\n",(0,i.jsxs)(t.p,{children:["To protect sensitive data while it resides in the implant's memory (heap), the MemStore implements a continuous obfuscation strategy. Raw data is ",(0,i.jsx)(t.strong,{children:"never"})," stored in plain text."]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Ingestion (XOR Encoding):"}),"\nWhen data is stored, it is immediately scrambled using an XOR operation. The encryption key used for this process is the ",(0,i.jsx)(t.strong,{children:"filename (Key)"})," itself. It's not super secure, but it's enough to ensuring that two identical files stored under different names will look completely different to a memory scanner (which is the whole point here, detection evasion). The key name can be as long as you want, it's stored via a ",(0,i.jsx)(t.code,{children:"std::string"}),", so go ham."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"At Rest:"}),"\nWhile sitting in memory, the data remains in this scrambled state. This aims to defeat memory scanners that look for specific static signatures (like PE headers or config strings) within the implant's allocated memory."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Retrieval:"}),"\nThe data is only decoded when explicitly needed (e.g., C2 operator using the value). The retrieval process creates a temporary copy, unscrambles it to restore the original format, and returns it for immediate use."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"memory-hygiene--ownership",children:"Memory Hygiene & Ownership"}),"\n",(0,i.jsx)(t.p,{children:"[ need to verify to be 100% sure ]"}),"\n",(0,i.jsx)(t.p,{children:"The MemStore is designed to minimize the proliferation of sensitive data copies in memory."}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Ownership Transfer:"}),' When a module passes data to the store, ownership is transferred rather than copied. This prevents "ghost copies" of the data from lingering in the memory of the calling function.']}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Destructive Updates:"})," Overwriting a key completely replaces the underlying data, releasing the old memory block immediately."]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"integration-with-c2-commands-not-implemented",children:"Integration with C2 Commands [not implemented]"}),"\n",(0,i.jsxs)(t.p,{children:["The MemStore is the backend that powers the ",(0,i.jsxs)(t.strong,{children:["Dereference Operator (",(0,i.jsx)(t.code,{children:"*"}),")"]}),". (see the ",(0,i.jsx)(t.code,{children:"Commands"})," docs)"]}),"\n",(0,i.jsxs)(t.p,{children:["When a user issues a command like ",(0,i.jsx)(t.code,{children:"file upload C:\\Target\\out.exe *my_tool"}),", the implant:"]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["Detects the ",(0,i.jsx)(t.code,{children:"*"})," prefix."]}),"\n",(0,i.jsxs)(t.li,{children:["Looks up ",(0,i.jsx)(t.code,{children:"my_tool"})," in the MemStore."]}),"\n",(0,i.jsx)(t.li,{children:"Decodes the binary data on the fly."}),"\n",(0,i.jsx)(t.li,{children:"Uses that data for the upload."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["This allows operators to upload tools to the implant ",(0,i.jsx)(t.em,{children:"once"}),", and then deploy them to multiple locations or use them in multiple ways without re-transmitting data over the network."]})]})}function c(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453(e,t,n){n.d(t,{R:()=>o,x:()=>a});var s=n(6540);const i={},r=s.createContext(i);function o(e){const t=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);